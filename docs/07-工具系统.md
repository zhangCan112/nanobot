# å·¥å…·ç³»ç»Ÿè¯¦è§£

## ğŸ“‹ ç³»ç»Ÿæ¦‚è¿°

nanobot çš„å·¥å…·ç³»ç»ŸåŸºäº `nanobot/agent/tools/` ç›®å½•å®ç°ï¼Œæä¾›äº† Agent ä¸ç¯å¢ƒäº¤äº’çš„èƒ½åŠ›ã€‚

## ğŸ¯ æ ¸å¿ƒæ¶æ„

```
Tool (æŠ½è±¡åŸºç±»)
â”œâ”€â”€ name: å·¥å…·åç§°
â”œâ”€â”€ description: å·¥å…·æè¿°
â”œâ”€â”€ parameters: å‚æ•°å®šä¹‰ (JSON Schema)
â””â”€â”€ execute(): æ‰§è¡Œæ–¹æ³•

ToolRegistry (å·¥å…·æ³¨å†Œè¡¨)
â”œâ”€â”€ register(): æ³¨å†Œå·¥å…·
â”œâ”€â”€ unregister(): æ³¨é”€å·¥å…·
â”œâ”€â”€ execute(): æ‰§è¡Œå·¥å…·
â””â”€â”€ get_definitions(): è·å–æ‰€æœ‰å·¥å…·å®šä¹‰
```

## ğŸ“ å†…ç½®å·¥å…·åˆ—è¡¨

### 1. æ–‡ä»¶ç³»ç»Ÿå·¥å…·
- **ReadFileTool**: è¯»å–æ–‡ä»¶å†…å®¹
- **WriteFileTool**: å†™å…¥æ–‡ä»¶
- **EditFileTool**: ç¼–è¾‘æ–‡ä»¶ï¼ˆæ–‡æœ¬æ›¿æ¢ï¼‰
- **ListDirTool**: åˆ—å‡ºç›®å½•å†…å®¹

### 2. Shell å·¥å…·
- **ExecTool**: æ‰§è¡Œ Shell å‘½ä»¤

### 3. Web å·¥å…·
- **WebSearchTool**: Web æœç´¢
- **WebFetchTool**: è·å–ç½‘é¡µå†…å®¹

### 4. æ¶ˆæ¯å·¥å…·
- **MessageTool**: å‘é€æ¶ˆæ¯åˆ°æ¸ é“

### 5. å­ä»£ç†å·¥å…·
- **SpawnTool**: ç”Ÿæˆå­ä»£ç†

### 6. å®šæ—¶ä»»åŠ¡å·¥å…·
- **CronTool**: ç®¡ç†å®šæ—¶ä»»åŠ¡

## ğŸ—ï¸ å·¥å…·åŸºç±» (Tool)

### æ–‡ä»¶ä½ç½®
`nanobot/agent/tools/base.py`

### æ ¸å¿ƒæ¥å£

```python
class Tool(ABC):
    """
    Abstract base class for agent tools.
    
    Tools are capabilities that the agent can use to interact with
    the environment, such as reading files, executing commands, etc.
    """
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Tool name used in function calls."""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """Description of what the tool does."""
        pass
    
    @property
    @abstractmethod
    def parameters(self) -> dict[str, Any]:
        """JSON Schema for tool parameters."""
        pass
    
    @abstractmethod
    async def execute(self, **kwargs: Any) -> str:
        """
        Execute the tool with given parameters.
        
        Args:
            **kwargs: Tool-specific parameters.
        
        Returns:
            String result of the tool execution.
        """
        pass
    
    def validate_params(self, params: dict[str, Any]) -> list[str]:
        """Validate tool parameters against JSON schema."""
        pass
    
    def to_schema(self) -> dict[str, Any]:
        """Convert tool to OpenAI function schema format."""
        pass
```

### å‚æ•°éªŒè¯

Tool åŸºç±»å®ç°äº†å®Œæ•´çš„ JSON Schema éªŒè¯ï¼š

```python
def validate_params(self, params: dict[str, Any]) -> list[str]:
    """Validate tool parameters. Returns error list (empty if valid)."""
    errors = self._validate(params, schema, "")
    return errors

def _validate(self, val: Any, schema: dict, path: str) -> list[str]:
    """é€’å½’éªŒè¯å‚æ•°"""
    # æ”¯æŒçš„ç±»å‹ï¼šstring, integer, number, boolean, array, object
    # æ”¯æŒçš„çº¦æŸï¼šminimum, maximum, minLength, maxLength, enum
    # æ”¯æŒçš„åµŒå¥—ï¼šproperties, required, items
```

### OpenAI æ ¼å¼è½¬æ¢

```python
def to_schema(self) -> dict[str, Any]:
    """Convert tool to OpenAI function schema format."""
    return {
        "type": "function",
        "function": {
            "name": self.name,
            "description": self.description,
            "parameters": self.parameters,
        }
    }
```

## ğŸ—‚ï¸ å·¥å…·æ³¨å†Œè¡¨ (ToolRegistry)

### æ–‡ä»¶ä½ç½®
`nanobot/agent/tools/registry.py`

### æ ¸å¿ƒæ–¹æ³•

```python
class ToolRegistry:
    """Registry for agent tools."""
    
    def __init__(self):
        self._tools: dict[str, Tool] = {}
    
    def register(self, tool: Tool) -> None:
        """Register a tool."""
        self._tools[tool.name] = tool
    
    def unregister(self, name: str) -> None:
        """Unregister a tool by name."""
        self._tools.pop(name, None)
    
    def get(self, name: str) -> Tool | None:
        """Get a tool by name."""
        return self._tools.get(name)
    
    def execute(self, name: str, params: dict[str, Any]) -> str:
        """Execute a tool by name with given parameters."""
        tool = self._tools.get(name)
        if not tool:
            return f"Error: Tool '{name}' not found"
        
        # éªŒè¯å‚æ•°
        errors = tool.validate_params(params)
        if errors:
            return f"Error: Invalid parameters: " + "; ".join(errors)
        
        # æ‰§è¡Œå·¥å…·
        return await tool.execute(**params)
    
    def get_definitions(self) -> list[dict[str, Any]]:
        """Get all tool definitions in OpenAI format."""
        return [tool.to_schema() for tool in self._tools.values()]
```

## ğŸ“ æ–‡ä»¶ç³»ç»Ÿå·¥å…·

### ReadFileTool - è¯»å–æ–‡ä»¶

```python
class ReadFileTool(Tool):
    @property
    def name(self) -> str:
        return "read_file"
    
    @property
    def description(self) -> str:
        return "Read the content of a file"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Path to the file to read"
                }
            },
            "required": ["path"]
        }
    
    async def execute(self, path: str, **kwargs) -> str:
        file_path = _resolve_path(path, self.allowed_dir)
        return file_path.read_text(encoding="utf-8")
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**
```python
# LLM è°ƒç”¨
{
    "name": "read_file",
    "arguments": {"path": "README.md"}
}

# ç»“æœ
"# nanobot\n\nThis is a project..."
```

### WriteFileTool - å†™å…¥æ–‡ä»¶

```python
class WriteFileTool(Tool):
    @property
    def name(self) -> str:
        return "write_file"
    
    @property
    def description(self) -> str:
        return "Write content to a file (creates or overwrites)"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "path": {"type": "string", "description": "File path"},
                "content": {"type": "string", "description": "Content to write"}
            },
            "required": ["path", "content"]
        }
    
    async def execute(self, path: str, content: str, **kwargs) -> str:
        file_path = _resolve_path(path, self.allowed_dir)
        file_path.write_text(content, encoding="utf-8")
        return f"Wrote {len(content)} characters to {path}"
```

### EditFileTool - ç¼–è¾‘æ–‡ä»¶

```python
class EditFileTool(Tool):
    @property
    def name(self) -> str:
        return "edit_file"
    
    @property
    def description(self) -> str:
        return "Replace text in a file"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "path": {"type": "string", "description": "File path"},
                "old_text": {"type": "string", "description": "Text to replace"},
                "new_text": {"type": "string", "description": "Replacement text"}
            },
            "required": ["path", "old_text", "new_text"]
        }
    
    async def execute(self, path: str, old_text: str, new_text: str, **kwargs) -> str:
        file_path = _resolve_path(path, self.allowed_dir)
        content = file_path.read_text(encoding="utf-8")
        
        if old_text not in content:
            return f"Error: '{old_text}' not found in {path}"
        
        new_content = content.replace(old_text, new_text, 1)  # åªæ›¿æ¢ç¬¬ä¸€æ¬¡å‡ºç°
        file_path.write_text(new_content, encoding="utf-8")
        
        count = new_content.count(new_text) - content.count(new_text) + 1
        return f"Replaced {count} occurrence(s) in {path}"
```

### ListDirTool - åˆ—å‡ºç›®å½•

```python
class ListDirTool(Tool):
    @property
    def name(self) -> str:
        return "list_dir"
    
    @property
    def description(self) -> str:
        return "List files and directories in a path"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Directory path (default: current directory)"
                }
            }
        }
    
    async def execute(self, path: str = ".", **kwargs) -> str:
        dir_path = _resolve_path(path, self.allowed_dir)
        
        if not dir_path.is_dir():
            return f"Error: {path} is not a directory"
        
        items = []
        for item in dir_path.iterdir():
            item_type = "DIR" if item.is_dir() else "FILE"
            items.append(f"[{item_type}] {item.name}")
        
        return "\n".join(items)
```

## ğŸ’» Shell å·¥å…·

### ExecTool - æ‰§è¡Œå‘½ä»¤

```python
class ExecTool(Tool):
    def __init__(
        self,
        working_dir: str,
        timeout: int = 60,
        restrict_to_workspace: bool = False
    ):
        self.working_dir = working_dir
        self.timeout = timeout
        self.restrict_to_workspace = restrict_to_workspace
    
    @property
    def name(self) -> str:
        return "exec"
    
    @property
    def description(self) -> str:
        return "Execute a shell command"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "Shell command to execute"
                },
                "working_dir": {
                    "type": "string",
                    "description": "Working directory (optional)"
                }
            },
            "required": ["command"]
        }
    
    async def execute(self, command: str, working_dir: str | None = None, **kwargs) -> str:
        # å‘½ä»¤å®ˆå«ï¼ˆå®‰å…¨æ£€æŸ¥ï¼‰
        warning = self._guard_command(command, cwd or self.working_dir)
        if warning:
            return warning
        
        # æ‰§è¡Œå‘½ä»¤
        process = await asyncio.create_subprocess_shell(
            command,
            cwd=working_dir or self.working_dir,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=self.timeout
            )
        except asyncio.TimeoutError:
            process.kill()
            return f"Command timed out after {self.timeout}s"
        
        return stdout.decode() + stderr.decode()
```

**å®‰å…¨ç‰¹æ€§ï¼š**
- å‘½ä»¤å®ˆå«æ£€æŸ¥å±é™©å‘½ä»¤
- è¶…æ—¶ä¿æŠ¤
- å·¥ä½œç©ºé—´é™åˆ¶

## ğŸŒ Web å·¥å…·

### WebSearchTool - Web æœç´¢

```python
class WebSearchTool(Tool):
    def __init__(self, api_key: str | None = None, max_results: int = 5):
        self.api_key = api_key
        self.max_results = max_results
    
    @property
    def name(self) -> str:
        return "web_search"
    
    @property
    def description(self) -> str:
        return "Search the web for information"
    
    async def execute(self, query: str, count: int | None = None, **kwargs) -> str:
        if not self.api_key:
            return "Error: No API key configured for web search"
        
        # è°ƒç”¨ Brave Search API
        url = f"https://api.search.brave.com/res/v1/web/search?q={query}&count={count or self.max_results}"
        headers = {"X-Subscription-Token": self.api_key}
        
        response = requests.get(url, headers=headers)
        results = response.json().get("web", {}).get("results", [])
        
        # æ ¼å¼åŒ–ç»“æœ
        formatted = []
        for result in results:
            formatted.append(f"- {result['title']}")
            formatted.append(f"  {result['url']}")
            formatted.append(f"  {result.get('description', '')[:200]}")
        
        return "\n\n".join(formatted)
```

### WebFetchTool - è·å–ç½‘é¡µ

```python
class WebFetchTool(Tool):
    def __init__(self, max_chars: int = 50000):
        self.max_chars = max_chars
    
    @property
    def name(self) -> str:
        return "web_fetch"
    
    @property
    def description(self) -> str:
        return "Fetch and parse a web page"
    
    async def execute(self, url: str, extractMode: str = "markdown", **kwargs) -> str:
        # éªŒè¯ URL
        valid, error = _validate_url(url)
        if not valid:
            return error
        
        # è·å–é¡µé¢
        response = requests.get(url, timeout=10)
        html = response.text
        
        # æå–æ¨¡å¼
        if extractMode == "markdown":
            content = self._to_markdown(html)
        else:
            content = _strip_tags(html)
        
        # æˆªæ–­
        if len(content) > self.max_chars:
            content = content[:self.max_chars] + "\n\n... (truncated)"
        
        return content
```

## ğŸ’¬ æ¶ˆæ¯å·¥å…·

### MessageTool - å‘é€æ¶ˆæ¯

```python
class MessageTool(Tool):
    def __init__(self, send_callback: Callable):
        self.send_callback = send_callback
        self._channel = None
        self._chat_id = None
    
    def set_context(self, channel: str, chat_id: str) -> None:
        """Set current channel and chat_id."""
        self._channel = channel
        self._chat_id = chat_id
    
    @property
    def name(self) -> str:
        return "message"
    
    @property
    def description(self) -> str:
        return "Send a message to a chat channel"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "channel": {
                    "type": "string",
                    "description": "Channel name (telegram, whatsapp, discord, feishu)",
                    "enum": ["telegram", "whatsapp", "discord", "feishu"]
                },
                "chat_id": {
                    "type": "string",
                    "description": "Recipient chat/user ID"
                },
                "content": {
                    "type": "string",
                    "description": "Message content"
                }
            },
            "required": ["channel", "chat_id", "content"]
        }
    
    async def execute(self, channel: str, chat_id: str, content: str, **kwargs) -> str:
        msg = OutboundMessage(
            channel=channel,
            chat_id=chat_id,
            content=content
        )
        await self.send_callback(msg)
        return f"Sent message to {channel}:{chat_id}"
```

**ä½¿ç”¨åœºæ™¯ï¼š**
- ä»ä¸€ä¸ªæ¸ é“è½¬å‘æ¶ˆæ¯åˆ°å¦ä¸€ä¸ªæ¸ é“
- ä¸»åŠ¨å‘é€é€šçŸ¥
- æ‰¹é‡æ¶ˆæ¯å‘é€

## ğŸ¤– å­ä»£ç†å·¥å…·

### SpawnTool - ç”Ÿæˆå­ä»£ç†

```python
class SpawnTool(Tool):
    def __init__(self, manager: SubagentManager):
        self.manager = manager
    
    def set_context(self, channel: str, chat_id: str) -> None:
        """Set current session context."""
        self._channel = channel
        self._chat_id = chat_id
    
    @property
    def name(self) -> str:
        return "spawn"
    
    @property
    def description(self) -> str:
        return "Spawn a subagent for background task"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "task": {
                    "type": "string",
                    "description": "Task description for the subagent"
                },
                "label": {
                    "type": "string",
                    "description": "Optional label for the subagent"
                }
            },
            "required": ["task"]
        }
    
    async def execute(self, task: str, label: str | None = None, **kwargs) -> str:
        subagent = await self.manager.spawn(
            task=task,
            label=label,
            origin_channel=self._channel,
            origin_chat_id=self._chat_id
        )
        return f"Spawned subagent '{label or subagent.id}'"
```

**ä½¿ç”¨åœºæ™¯ï¼š**
- å¹¶è¡Œå¤„ç†å¤šä¸ªç‹¬ç«‹ä»»åŠ¡
- é•¿æ—¶é—´è¿è¡Œçš„åå°ä»»åŠ¡
- å¤æ‚ä»»åŠ¡çš„åˆ†è§£

## â° å®šæ—¶ä»»åŠ¡å·¥å…·

### CronTool - ç®¡ç† Cron

```python
class CronTool(Tool):
    def __init__(self, cron_service: CronService):
        self.cron_service = cron_service
    
    def set_context(self, channel: str, chat_id: str) -> None:
        """Set current session context."""
        self._channel = channel
        self._chat_id = chat_id
    
    @property
    def name(self) -> str:
        return "cron"
    
    @property
    def description(self) -> str:
        return "Manage scheduled tasks"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to perform (add, list, remove)",
                    "enum": ["add", "list", "remove"]
                },
                "message": {
                    "type": "string",
                    "description": "Message for the task (for add action)"
                },
                "every_seconds": {
                    "type": "integer",
                    "description": "Run every N seconds (for add action)"
                },
                "cron_expr": {
                    "type": "string",
                    "description": "Cron expression (for add action)"
                }
            },
            "required": ["action"]
        }
    
    async def execute(self, action: str, **kwargs) -> str:
        if action == "add":
            return self._add_job(kwargs.get("message"), kwargs.get("every_seconds"), kwargs.get("cron_expr"))
        elif action == "list":
            return self._list_jobs()
        elif action == "remove":
            return self._remove_job(kwargs.get("job_id"))
```

## ğŸ”§ è‡ªå®šä¹‰å·¥å…·

### åˆ›å»ºè‡ªå®šä¹‰å·¥å…·

```python
from nanobot.agent.tools.base import Tool
from pathlib import Path
import json

class CustomTool(Tool):
    @property
    def name(self) -> str:
        return "custom_tool"
    
    @property
    def description(self) -> str:
        return "My custom tool description"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "param1": {
                    "type": "string",
                    "description": "First parameter"
                },
                "param2": {
                    "type": "integer",
                    "description": "Second parameter",
                    "minimum": 0,
                    "maximum": 100
                }
            },
            "required": ["param1"]
        }
    
    async def execute(self, param1: str, param2: int = 50, **kwargs) -> str:
        # å®ç°å·¥å…·é€»è¾‘
        result = f"Processed: {param1} with {param2}"
        return result
```

### æ³¨å†Œè‡ªå®šä¹‰å·¥å…·

```python
# åœ¨ AgentLoop çš„åˆå§‹åŒ–ä¸­
class AgentLoop:
    def __init__(self, ...):
        # ...
        self.tools = ToolRegistry()
        
        # æ³¨å†Œè‡ªå®šä¹‰å·¥å…·
        custom_tool = CustomTool()
        self.tools.register(custom_tool)
        
        # æˆ–è€…
        self._register_default_tools()
        self.tools.register(CustomTool())
```

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [01-é¡¹ç›®æ¦‚è¿°.md](./01-é¡¹ç›®æ¦‚è¿°.md) - é¡¹ç›®æ•´ä½“ä»‹ç»
- [04-Agentæ ¸å¿ƒ.md](./04-Agentæ ¸å¿ƒ.md) - Agent æ ¸å¿ƒé€»è¾‘
- [05-ä¸Šä¸‹æ–‡æ„å»º.md](./05-ä¸Šä¸‹æ–‡æ„å»º.md) - ä¸Šä¸‹æ–‡æ„å»ºè¯¦è§£

## ğŸ”— å…¶ä»–å·¥å…·æ–‡æ¡£

ç”±äºå·¥å…·ç³»ç»ŸåŒ…å«å¤šä¸ªç‹¬ç«‹å·¥å…·ï¼Œæ¯ä¸ªå·¥å…·çš„è¯¦ç»†è¯´æ˜è¯·å‚è€ƒï¼š
- [å·¥å…·åŸºç±».md](./å·¥å…·åŸºç±».md) - Tool æŠ½è±¡ç±»è¯¦è§£
- [æ–‡ä»¶å·¥å…·.md](./æ–‡ä»¶å·¥å…·.md) - æ–‡ä»¶ç³»ç»Ÿå·¥å…·è¯¦è§£
- [Shellå·¥å…·.md](./Shellå·¥å…·.md) - Shell æ‰§è¡Œå·¥å…·è¯¦è§£
- [Webå·¥å…·.md](./Webå·¥å…·.md) - Web æœç´¢å’Œè·å–å·¥å…·è¯¦è§£