# æ¸ é“ç³»ç»Ÿè¯¦è§£

## ğŸ“‹ ç³»ç»Ÿæ¦‚è¿°

nanobot çš„æ¸ é“ç³»ç»Ÿæ”¯æŒå¤šä¸ªèŠå¤©å¹³å°çš„é›†æˆï¼Œå…è®¸ç”¨æˆ·é€šè¿‡ Telegramã€WhatsAppã€Discord å’Œé£ä¹¦ä¸ AI äº¤äº’ã€‚

## ğŸ¯ æ ¸å¿ƒæ¶æ„

```
BaseChannel (æŠ½è±¡åŸºç±»)
â”œâ”€â”€ start(): å¯åŠ¨æ¸ é“
â”œâ”€â”€ stop(): åœæ­¢æ¸ é“
â”œâ”€â”€ send(): å‘é€æ¶ˆæ¯
â””â”€â”€ is_running: è¿è¡ŒçŠ¶æ€

ChannelManager (æ¸ é“ç®¡ç†å™¨)
â”œâ”€â”€ åˆå§‹åŒ–é…ç½®çš„æ¸ é“
â”œâ”€â”€ å¯åŠ¨/åœæ­¢æ‰€æœ‰æ¸ é“
â”œâ”€â”€ è·¯ç”±æ¶ˆæ¯åˆ° Agent
â””â”€â”€ åˆ†å‘å“åº”åˆ°æ¸ é“
```

## ğŸ“± æ”¯æŒçš„æ¸ é“

### 1. Telegram
**ç‰¹ç‚¹ï¼š**
- âœ… æœ€ç®€å•æ˜“ç”¨
- âœ… æ”¯æŒæœºå™¨äººæ¨¡å¼
- âœ… æ”¯æŒå›¾ç‰‡å’Œæ–‡ä»¶
- âœ… æ”¯æŒ Markdown æ ¼å¼

**è·å–æ–¹å¼ï¼š**
1. Telegram æœç´¢ `@BotFather`
2. å‘é€ `/newbot` åˆ›å»ºæœºå™¨äºº
3. å¤åˆ¶ç”Ÿæˆçš„ Token

### 2. WhatsApp
**ç‰¹ç‚¹ï¼š**
- âœ… ä¸ªäººæ¶ˆæ¯æ”¯æŒ
- âœ… éœ€è¦æ‰«ç ç™»å½•
- âœ… åŸç”Ÿä½“éªŒ

**è·å–æ–¹å¼ï¼š**
1. è¿è¡Œ `nanobot channels login`
2. æ‰«æ QR ç ç™»å½•
3. æ·»åŠ è”ç³»äºº

### 3. Discord
**ç‰¹ç‚¹ï¼š**
- âœ… æœåŠ¡å™¨å’Œç§ä¿¡
- âœ… ä¸°å¯Œçš„äº¤äº’åŠŸèƒ½
- âœ… æ”¯æŒåµŒå…¥æ¶ˆæ¯

**è·å–æ–¹å¼ï¼š**
1. Discord Developer Portal åˆ›å»ºåº”ç”¨
2. æ·»åŠ  Bot åŠŸèƒ½
3. è·å– Token å’Œé‚€è¯·é“¾æ¥

### 4. Feishu (é£ä¹¦)
**ç‰¹ç‚¹ï¼š**
- âœ… ä¼ä¸šçº§é›†æˆ
- âœ… WebSocket é•¿è¿æ¥
- âœ… æ”¯æŒå¯Œæ–‡æœ¬

**è·å–æ–¹å¼ï¼š**
1. é£ä¹¦å¼€æ”¾å¹³å°åˆ›å»ºåº”ç”¨
2. å¯ç”¨ Bot èƒ½åŠ›
3. é…ç½®äº‹ä»¶è®¢é˜…

## ğŸ—ï¸ æ¸ é“åŸºç±» (BaseChannel)

### æ–‡ä»¶ä½ç½®
`nanobot/channels/base.py`

### æ ¸å¿ƒæ¥å£

```python
class BaseChannel(ABC):
    """
    Abstract base class for chat channels.
    
    All channel implementations must inherit from this class
    and implement the required methods.
    """
    
    @abstractmethod
    async def start(self) -> None:
        """
        Start the channel connection.
        
        Should:
        - Initialize connection
        - Start receiving messages
        - Publish messages to message bus
        """
        pass
    
    @abstractmethod
    async def stop(self) -> None:
        """
        Stop the channel connection.
        
        Should:
        - Disconnect from service
        - Clean up resources
        - Set is_running to False
        """
        pass
    
    @abstractmethod
    async def send(self, message: OutboundMessage) -> None:
        """
        Send a message to the channel.
        
        Args:
            message: Message to send with channel, chat_id, content.
        """
        pass
    
    @property
    @abstractmethod
    def is_running(self) -> bool:
        """Check if channel is currently running."""
        pass
```

## ğŸ—‚ï¸ æ¸ é“ç®¡ç†å™¨ (ChannelManager)

### æ–‡ä»¶ä½ç½®
`nanobot/channels/manager.py`

### æ ¸å¿ƒåŠŸèƒ½

```python
class ChannelManager:
    """Manages chat channels and coordinates message routing."""
    
    def __init__(self, config: Config, bus: MessageBus):
        self.config = config
        self.bus = bus
        self.channels: dict[str, BaseChannel] = {}
        
        # åˆå§‹åŒ–é…ç½®çš„æ¸ é“
        self._init_channels()
    
    def _init_channels(self) -> None:
        """åˆå§‹åŒ–é…ç½®çš„æ¸ é“"""
        # Telegram
        if self.config.channels.telegram.enabled:
            from nanobot.channels.telegram import TelegramChannel
            self.channels["telegram"] = TelegramChannel(...)
        
        # WhatsApp
        if self.config.channels.whatsapp.enabled:
            from nanobot.channels.whatsapp import WhatsAppChannel
            self.channels["whatsapp"] = WhatsAppChannel(...)
        
        # Discord
        if self.config.channels.discord.enabled:
            from nanobot.channels.discord import DiscordChannel
            self.channels["discord"] = DiscordChannel(...)
        
        # Feishu
        if self.config.channels.feishu.enabled:
            from nanobot.channels.feishu import FeishuChannel
            self.channels["feishu"] = FeishuChannel(...)
```

### æ¶ˆæ¯è·¯ç”±

```python
async def _dispatch_outbound(self) -> None:
    """åˆ†å‘å‡ºç«™æ¶ˆæ¯åˆ°å¯¹åº”çš„æ¸ é“"""
    logger.info("Outbound dispatcher started")
    
    while True:
        try:
            # ç­‰å¾…æ¶ˆæ¯
            msg = await asyncio.wait_for(
                self.bus.consume_outbound(),
                timeout=1.0
            )
            
            # æŸ¥æ‰¾æ¸ é“
            channel = self.channels.get(msg.channel)
            if channel:
                try:
                    # å‘é€æ¶ˆæ¯
                    await channel.send(msg)
                except Exception as e:
                    logger.error(f"Error sending to {msg.channel}: {e}")
            else:
                logger.warning(f"Unknown channel: {msg.channel}")
                
        except asyncio.TimeoutError:
            continue
        except asyncio.CancelledError:
            break
```

### å¯åŠ¨å’Œåœæ­¢

```python
async def start_all(self) -> None:
    """å¯åŠ¨æ‰€æœ‰æ¸ é“"""
    if not self.channels:
        logger.warning("No channels enabled")
        return
    
    # å¯åŠ¨å‡ºç«™åˆ†å‘å™¨
    self._dispatch_task = asyncio.create_task(self._dispatch_outbound())
    
    # å¯åŠ¨æ‰€æœ‰æ¸ é“
    tasks = []
    for name, channel in self.channels.items():
        logger.info(f"Starting {name} channel...")
        tasks.append(asyncio.create_task(channel.start()))
    
    # ç­‰å¾…æ‰€æœ‰æ¸ é“å¯åŠ¨
    await asyncio.gather(*tasks, return_exceptions=True)

async def stop_all(self) -> None:
    """åœæ­¢æ‰€æœ‰æ¸ é“"""
    logger.info("Stopping all channels...")
    
    # åœæ­¢åˆ†å‘å™¨
    if self._dispatch_task:
        self._dispatch_task.cancel()
        try:
            await self._dispatch_task
        except asyncio.CancelledError:
            pass
    
    # åœæ­¢æ‰€æœ‰æ¸ é“
    for name, channel in self.channels.items():
        try:
            await channel.stop()
            logger.info(f"Stopped {name} channel")
        except Exception as e:
            logger.error(f"Error stopping {name}: {e}")
```

## ğŸ“¨ æ¶ˆæ¯æµ

### å…¥ç«™æ¶ˆæ¯æµç¨‹

```
ç”¨æˆ·æ¶ˆæ¯ (Telegram/WhatsApp/Discord/Feishu)
    â†“
Channel æ¥æ”¶æ¶ˆæ¯
    â†“
éªŒè¯ç”¨æˆ·ç™½åå•
    â†“
å‘å¸ƒåˆ°æ¶ˆæ¯æ€»çº¿
    â†“
AgentLoop å¤„ç†æ¶ˆæ¯
    â†“
ç”Ÿæˆå“åº”
    â†“
å‘å¸ƒåˆ°æ¶ˆæ¯æ€»çº¿
    â†“
ChannelManager è·¯ç”±
    â†“
Channel å‘é€å“åº”
    â†“
ç”¨æˆ·æ”¶åˆ°å›å¤
```

### å‡ºç«™æ¶ˆæ¯æµç¨‹

```
å·¥å…·è°ƒç”¨ message() æˆ– cron ä»»åŠ¡
    â†“
åˆ›å»º OutboundMessage
    â†“
å‘å¸ƒåˆ°æ¶ˆæ¯æ€»çº¿
    â†“
ChannelManager._dispatch_outbound()
    â†“
æ ¹æ® channel æŸ¥æ‰¾å¯¹åº”æ¸ é“
    â†“
channel.send(message)
    â†“
ç”¨æˆ·æ”¶åˆ°æ¶ˆæ¯
```

## ğŸ” å®‰å…¨ç‰¹æ€§

### ç”¨æˆ·ç™½åå•

æ‰€æœ‰æ¸ é“æ”¯æŒç™½åå•åŠŸèƒ½ï¼š

```python
# Telegram
if telegram_config.allow_from:
    if sender_id not in telegram_config.allow_from:
        logger.warning(f"Unauthorized user: {sender_id}")
        return

# WhatsApp
if whatsapp_config.allow_from:
    if phone_number not in whatsapp_config.allow_from:
        logger.warning(f"Unauthorized number: {phone_number}")
        return

# Discord
if discord_config.allow_from:
    if user_id not in discord_config.allow_from:
        logger.warning(f"Unauthorized user: {user_id}")
        return
```

### é€Ÿç‡é™åˆ¶

å»ºè®®åœ¨æ¸ é“å®ç°ä¸­æ·»åŠ é€Ÿç‡é™åˆ¶ï¼š

```python
class RateLimiter:
    def __init__(self, max_requests: int, period: float):
        self.max_requests = max_requests
        self.period = period
        self.requests = []
    
    async def acquire(self) -> bool:
        now = time.time()
        # æ¸…ç†è¿‡æœŸè¯·æ±‚
        self.requests = [r for r in self.requests if now - r < self.period]
        
        if len(self.requests) < self.max_requests:
            self.requests.append(now)
            return True
        
        # ç­‰å¾…
        wait_time = self.period - (now - self.requests[0])
        await asyncio.sleep(wait_time)
        return await self.acquire()
```

## ğŸ¨ æ¸ é“é…ç½®ç¤ºä¾‹

### Telegram é…ç½®

```json
{
  "channels": {
    "telegram": {
      "enabled": true,
      "token": "1234567890:ABCdefGHIjklMNOpqrsTUVwxyz",
      "allowFrom": ["123456789", "username"],
      "proxy": "socks5://127.0.0.1:1080"
    }
  }
}
```

### WhatsApp é…ç½®

```json
{
  "channels": {
    "whatsapp": {
      "enabled": true,
      "bridgeUrl": "ws://localhost:3001",
      "allowFrom": ["+1234567890", "+9876543210"]
    }
  }
}
```

### Discord é…ç½®

```json
{
  "channels": {
    "discord": {
      "enabled": true,
      "token": "MTIzNDU2Nzg5MA.xxxxx.xxxxx",
      "allowFrom": ["123456789012345678"],
      "gatewayUrl": "wss://gateway.discord.gg/?v=10&encoding=json",
      "intents": 37377
    }
  }
}
```

### Feishu é…ç½®

```json
{
  "channels": {
    "feishu": {
      "enabled": true,
      "appId": "cli_xxx",
      "appSecret": "xxx",
      "encryptKey": "",
      "verificationToken": "",
      "allowFrom": ["ou_xxx"]
    }
  }
}
```

## ğŸ”§ è‡ªå®šä¹‰æ¸ é“

### åˆ›å»ºæ–°æ¸ é“

```python
from nanobot.channels.base import BaseChannel
from nanobot.bus.events import InboundMessage, OutboundMessage
from loguru import logger

class CustomChannel(BaseChannel):
    def __init__(self, config, bus: MessageBus):
        self.config = config
        self.bus = bus
        self._running = False
    
    async def start(self) -> None:
        """å¯åŠ¨æ¸ é“"""
        self._running = True
        logger.info("Custom channel started")
        
        # åˆå§‹åŒ–è¿æ¥
        await self._connect()
        
        # å¼€å§‹æ¥æ”¶æ¶ˆæ¯
        await self._receive_loop()
    
    async def stop(self) -> None:
        """åœæ­¢æ¸ é“"""
        self._running = False
        logger.info("Custom channel stopped")
        await self._disconnect()
    
    async def send(self, message: OutboundMessage) -> None:
        """å‘é€æ¶ˆæ¯"""
        if not self._running:
            logger.warning("Channel not running")
            return
        
        # å®ç°å‘é€é€»è¾‘
        await self._send_to_service(message)
    
    @property
    def is_running(self) -> bool:
        """æ£€æŸ¥è¿è¡ŒçŠ¶æ€"""
        return self._running
    
    async def _connect(self) -> None:
        """è¿æ¥åˆ°æœåŠ¡"""
        # å®ç°è¿æ¥é€»è¾‘
        pass
    
    async def _disconnect(self) -> None:
        """æ–­å¼€è¿æ¥"""
        # å®ç°æ–­å¼€é€»è¾‘
        pass
    
    async def _receive_loop(self) -> None:
        """æ¥æ”¶æ¶ˆæ¯å¾ªç¯"""
        while self._running:
            try:
                # æ¥æ”¶æ¶ˆæ¯
                msg = await self._receive_from_service()
                
                # å‘å¸ƒåˆ°æ¶ˆæ¯æ€»çº¿
                inbound = InboundMessage(
                    channel="custom",
                    sender_id=msg.sender,
                    chat_id=msg.chat_id,
                    content=msg.text,
                    media=msg.media
                )
                await self.bus.publish_inbound(inbound)
            except Exception as e:
                logger.error(f"Error receiving message: {e}")
                await asyncio.sleep(1)
    
    async def _send_to_service(self, message: OutboundMessage) -> None:
        """å‘é€åˆ°æœåŠ¡"""
        # å®ç°å‘é€é€»è¾‘
        pass
    
    async def _receive_from_service(self) -> Any:
        """ä»æœåŠ¡æ¥æ”¶"""
        # å®ç°æ¥æ”¶é€»è¾‘
        pass
```

### æ³¨å†Œè‡ªå®šä¹‰æ¸ é“

```python
# åœ¨ ChannelManager._init_channels() ä¸­æ·»åŠ 
def _init_channels(self) -> None:
    # ... ç°æœ‰æ¸ é“
    
    # è‡ªå®šä¹‰æ¸ é“
    if self.config.channels.custom.enabled:
        from my_channels import CustomChannel
        self.channels["custom"] = CustomChannel(
            self.config.channels.custom,
            self.bus
        )
```

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [01-é¡¹ç›®æ¦‚è¿°.md](./01-é¡¹ç›®æ¦‚è¿°.md) - é¡¹ç›®æ•´ä½“ä»‹ç»
- [02-CLIå‘½ä»¤ç³»ç»Ÿ.md](./02-CLIå‘½ä»¤ç³»ç»Ÿ.md) - æ¸ é“ç®¡ç†å‘½ä»¤
- [03-é…ç½®ç³»ç»Ÿ.md](./03-é…ç½®ç³»ç»Ÿ.md) - æ¸ é“é…ç½®è¯´æ˜
- [12-æ¶ˆæ¯æ€»çº¿.md](./12-æ¶ˆæ¯æ€»çº¿.md) - æ¶ˆæ¯æ€»çº¿è¯¦è§£

## ğŸ”— æ¸ é“æ–‡æ¡£

### Telegram è¯¦ç»†æ–‡æ¡£
- Bot API: https://core.telegram.org/bots/api
- Telethon: https://docs.telethon.dev

### WhatsApp è¯¦ç»†æ–‡æ¡£
- Baileys: https://github.com/WhiskeySockets/Baileys

### Discord è¯¦ç»†æ–‡æ¡£
- Discord.py: https://discordpy.readthedocs.io
- Discord API: https://discord.com/developers/docs

### Feishu è¯¦ç»†æ–‡æ¡£
- é£ä¹¦å¼€æ”¾å¹³å°: https://open.feishu.cn
- Bot API: https://open.feishu.cn/document/server-docs/bot-overview